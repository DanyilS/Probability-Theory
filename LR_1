# Selivanov Danyil


# coding: utf-8

# In[1]:


def permute(A):
    if len(A)==1:
        return [tuple(A)]
    permutations = []
    for x in A:
        for y in permute(A-{x}):
            permutations.append((x,)+y)
    return permutations


# In[2]:


A = {1, 2, 3}


# In[3]:


permute_all = set(permute(A))
print("Перестановки множини {}: {}".format(A,permute_all))
print("Кількість перестановок: ", len(permute_all))


# In[4]:


from itertools import permutations


# In[5]:


A = {1, 2, 3}


# In[6]:


# Використовуючи бібліотеку itertools
permute_all = set(permutations(A))
print("Перестановки множини {}: {}".format(A,permute_all))
print("Кількість перестановок: ", len(permute_all))


# In[9]:


#Task 1.3
A = {1, 3, 5}
B = {1, 2, 3, 4}
C = {1, 2, 2, 1}

permute_all = set(permutations(A))
print("Перестановки множини {}: {}".format(A,permute_all))
print("Кількість перестановок: ", len(permute_all), '\n')

permute_all = set(permutations(B))
print("Перестановки множини {}: {}".format(B,permute_all))
print("Кількість перестановок: ", len(permute_all), '\n')

permute_all = set(permutations(C))
print("Перестановки множини {}: {}".format(C,permute_all))
print("Кількість перестановок: ", len(permute_all), '\n')
print("---------------------------")
A = {1, 2, 3, 4, 5}
B = {1, 2, 3, 4, 5, 6, 7}
C = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19}

permute_all = set(permutations(A))
print("Кількість перестановок множини {}: ".format(A), len(permute_all), '\n')

permute_all = set(permutations(B))
print("Кількість перестановок множини {}: ".format(B), len(permute_all), '\n')

permute_all = set(permutations(C))
print("Кількість перестановок множини {}: ".format(C), len(permute_all), '\n')


# In[24]:


# Task 1.4
from itertools import permutations

A = {1, 2, 3}
B = {1, 2, 3, 4}
C = {1, 3, 5, 7}
D = {1, 2, 2, 1}


def permute_without_points(S):
    """
    A function that iterates over all possible permutations without non-movable points.
    :param S: data sets
    :return: such possible permutations and the number of them.
    """

    possible_perm = []
    all_perm = list(permutations(S))

    for perm in all_perm:
        bool = True

        for number in range(len(perm)):
            if (perm[number] == number + 1):
                bool = False
                break

        if bool:
            possible_perm.append(perm)

    return set(possible_perm)

print("Можливі перестановки без нерухомих точок множини {}: ".format(A), permute_without_points(A), "\nЇх кількість: ", len(permute_without_points(A)), "\n")
print("Можливі перестановки без нерухомих точок множини {}: ".format(B), permute_without_points(B), "\nЇх кількість: ", len(permute_without_points(B)), "\n")
print("Можливі перестановки без нерухомих точок множини {}: ".format(C), permute_without_points(C), "\nЇх кількість: ", len(permute_without_points(C)), "\n")
print("Можливі перестановки без нерухомих точок множини {}: ".format(D), permute_without_points(D), "\nЇх кількість: ", len(permute_without_points(D)), "\n")


# In[25]:


from itertools import permutations

A = {1, 2, 3, 4, 5, 6, 7, 8}
B = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

def perm_upp_dowm(S):
    """
    A function that considers all possible permutations
    under these conditions (the first 4 increase,
    all the others fall off)
    :param S: data sets
    :return: such possible permutations and the number of them.
    """

    possible_perm = []
    all_perm = list(permutations(S))

    for perm in all_perm:

        if (perm[0] < perm[1] < perm[2] < perm[3]):
            other = perm[4:]
            bool = False
            for i in range(len(other)-1):
                if other[i] < other[i+1]:
                    bool = False
                    break
                else:
                    bool = True
            if bool:
                possible_perm.append(perm)
    return possible_perm
print("Можливі перестановки (4 перші зростають, інші спадають) множини {}: ".format(A), perm_upp_dowm(A), "\nЇх кількість: ", len(perm_upp_dowm(A)), "\n")
print("Можливі перестановки (4 перші зростають, інші спадають) множини {}: ".format(B), perm_upp_dowm(B), "\nЇх кількість: ", len(perm_upp_dowm(B)), "\n")


# In[28]:


A = {1, 2, 3}
k = 2
# перестановки довжини k множини A
permute_k = list(permutations(A, k))
print("Перестановки довжини {} множини {}: {}".format(k, A, permute_k))
print("Кількість таких перестановок: {}".format(len(permute_k)))


# In[43]:


#Task 2.2
n, k = 4, 2
print("Всі можливі часткові перестановки множини з {} елементів розміром {}:\n".format(n, k), list(permutations({1,2,3,4}, k)), "\nЇх кількість:", len(list(permutations({1,2,3,4}, k))))
n, k = 4, 3
print("\nВсі можливі часткові перестановки множини з {} елементів розміром {}:\n".format(n, k), list(permutations({1,2,3,4}, k)), "\nЇх кількість:", len(list(permutations({1,2,3,4}, k))))
n, k = 5, 2
print("\nВсі можливі часткові перестановки множини з {} елементів розміром {}:\n".format(n, k), list(permutations({1,2,3,4,5}, k)), "\nЇх кількість:", len(list(permutations({1,2,3,4,5}, k))))
print("----------------")
print("Кількість часткових перестановок множини з {} елементів розміром {} =".format({1,2,3,4,5,6},2), len(list(permutations({1,2,3,4,5,6}, 2))))
print("Кількість часткових перестановок множини з {} елементів розміром {} =".format({1,2,3,4,5,6},4), len(list(permutations({1,2,3,4,5,6}, 4))))
print("Кількість часткових перестановок множини з {} елементів розміром {} =".format({1,2,3,4,5,6,7,8},4), len(list(permutations({1,2,3,4,5,6,7,8}, 4))))


# In[44]:


from itertools import combinations


# In[45]:


A = {1, 2, 3}
k = 2


# In[47]:


# комбінації довжини k множини A
choose_k = list(combinations(A,k))
print("Комбінації довжини {} множини {}: {}".format(k,A,choose_k))
print("Кількість таких комбінацій: {}".format(len(choose_k)  ))


# In[9]:


#Task 3.2
from itertools import combinations
n, k = 4, 2
print("Всі можливі комбінації без повторень множини з {} елементів розміром {}:\n".format(n, k), list(combinations({1,2,3,4}, k)), "\nЇх кількість:", len(list(combinations({1,2,3,4}, k))))
n, k = 4, 3
print("\nВсі можливі комбінації без повторень множини з {} елементів розміром {}:\n".format(n, k), list(combinations({1,2,3,4}, k)), "\nЇх кількість:", len(list(combinations({1,2,3,4}, k))))
n, k = 5, 2
print("\nВсі можливі комбінації без повторень множини з {} елементів розміром {}:\n".format(n, k), list(combinations({1,2,3,4,5}, k)), "\nЇх кількість:", len(list(combinations({1,2,3,4,5}, k))))
print("----------------")
print("Кількість комбінації без повторень множини з {} елементів розміром {} =".format({1,2,3,4,5,6},2), len(list(combinations({1,2,3,4,5,6}, 2))))
print("Кількість комбінації без повторень множини з {} елементів розміром {} =".format({1,2,3,4,5,6},4), len(list(combinations({1,2,3,4,5,6}, 4))))
print("Кількість комбінації без повторень множини з {} елементів розміром {} =".format({1,2,3,4,5,6,7,8},4), len(list(combinations({1,2,3,4,5,6,7,8}, 4))))


# In[5]:


#Task 3.3
"""
Скільки елементів може бути в множині, яка складається із попарних сум елементів множини ? 
На справді задача пошуку можливої кількості елементів в множині попарних сум елементів з множини А
зводиться до того, що потрібно порахувати кількість комбінацій елементів з множини А розміром 2.
"""

from itertools import combinations

A = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} # наприклад
print("В множині В, яка складається із попарних сум елементів множини А може бути {} елементів.".format(len(list(combinations(A, 2)))))


# In[6]:


#Task 4.1

from itertools import combinations_with_replacement
A = {1, 2, 3}
k = 2
# комбінації довжини k множини A
choose_k = list(combinations_with_replacement(A,k))
print("Комбінації довжини {} множини {}: {}".format(k,A,choose_k))
print("Кількість таких комбінацій: {}".format(len(choose_k)  ))


# In[10]:


#Task 4.2

from itertools import combinations_with_replacement

n, k = 4, 2
print("Всі можливі комбінації з повтореннями множини з {} елементів розміром {}:\n".format(n, k), list(combinations_with_replacement({1,2,3,4}, k)), "\nЇх кількість:", len(list(combinations_with_replacement({1,2,3,4}, k))))
n, k = 4, 3
print("\nВсі можливі комбінації з повтореннями множини з {} елементів розміром {}:\n".format(n, k), list(combinations_with_replacement({1,2,3,4}, k)), "\nЇх кількість:", len(list(combinations_with_replacement({1,2,3,4}, k))))
n, k = 5, 2
print("\nВсі можливі комбінації з повтореннями множини з {} елементів розміром {}:\n".format(n, k), list(combinations_with_replacement({1,2,3,4,5}, k)), "\nЇх кількість:", len(list(combinations_with_replacement({1,2,3,4,5}, k))))
print("----------------")
print("Кількість комбінацій з повтореннями множини з {} елементів розміром {} =".format({1,2,3,4,5,6},2), len(list(combinations_with_replacement({1,2,3,4,5,6}, 2))))
print("Кількість комбінацій з повтореннями множини з {} елементів розміром {} =".format({1,2,3,4,5,6},4), len(list(combinations_with_replacement({1,2,3,4,5,6}, 4))))
print("Кількість комбінацій з повтореннями множини з {} елементів розміром {} =".format({1,2,3,4,5,6,7,8},4), len(list(combinations_with_replacement({1,2,3,4,5,6,7,8}, 4))))


# In[14]:


#Task 4.3  //it seems to be wrong :) \\
"""
Питання розв'язку задачі: яку множину можливих чисел використовувати? Я взяв {1, 2, 3, 4, 5, 6}, 
але тут відповідь буде очевидною.
"""
from itertools import combinations_with_replacement

A = {1, 2, 3, 4, 5, 6}
k = 6
# комбінації довжини k множини A
choose_k = list(combinations_with_replacement(A,k))

poss_comb = []
count = 0
for comb in choose_k:
    if ((comb[0] + comb[1] + comb[2]) == comb[3] + comb[4] + comb[5]):
        count += 1
        poss_comb.append(comb)

print("Такі комбінації 6 цифр, щоб сума перших трьох була б рівною сумі останніх трьох:\n{}\nЇх кількість: {}".format(poss_comb, count))


# In[24]:


#Task 4.4

from itertools import combinations_with_replacement

A = {1, 2, 3, 4, 5, 6}
k = 6
# комбінації довжини k множини A
choose_k = list(combinations_with_replacement(A,k))

poss_comb = []
count = 0

for comb in choose_k:
    bool = True
    for num in range(len(comb)-1):
        if comb[num] == comb[num+1]:
            bool = False
            break
            
    if bool:
        poss_comb.append(comb)
print("Такі комбінації 6 цифр, щоб дві однакові цифри не стояли поряд:\n{}\nЇх кількість: {}".format(poss_comb, len(poss_comb)))

